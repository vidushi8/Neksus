// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   alpha/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

    Fault
    Nop::execute(CPU_EXEC_CONTEXT *, Trace::InstRecord *) const
    {
        return NoFault;
    }

    /// Check "FP enabled" machine status bit.  Called when executing any FP
    /// instruction in full-system mode.
    /// @retval Full-system mode: NoFault if FP is enabled, FenFault
    /// if not.  Non-full-system mode: always returns NoFault.
    inline Fault checkFpEnableFault(CPU_EXEC_CONTEXT *xc)
    {
        Fault fault = NoFault;  // dummy... this ipr access should not fault
        if (FullSystem && !ICSR_FPE(xc->readMiscReg(IPR_ICSR))) {
            fault = new FloatEnableFault;
        }
        return fault;
    }

    Fault
    OpcdecFault::execute(CPU_EXEC_CONTEXT *xc,
                     Trace::InstRecord *traceData) const
    {
        return new UnimplementedOpcodeFault;
    }

    Fault
    FailUnimplemented::execute(CPU_EXEC_CONTEXT *xc,
                               Trace::InstRecord *traceData) const
    {
        panic("attempt to execute unimplemented instruction '%s' "
              "(inst 0x%08x, opcode 0x%x)", mnemonic, machInst, OPCODE);
        return new UnimplementedOpcodeFault;
    }

    Fault
    WarnUnimplemented::execute(CPU_EXEC_CONTEXT *xc,
                               Trace::InstRecord *traceData) const
    {
        if (!warned) {
            warn("instruction '%s' unimplemented\n", mnemonic);
            warned = true;
        }

        return NoFault;
    }

    Fault
    Unknown::execute(CPU_EXEC_CONTEXT *xc,
                     Trace::InstRecord *traceData) const
    {
        panic("attempt to execute unknown instruction "
              "(inst 0x%08x, opcode 0x%x)", machInst, OPCODE);
        return new UnimplementedOpcodeFault;
    }


    /// Return opa + opb, summing carry into third arg.
    inline uint64_t
    addc(uint64_t opa, uint64_t opb, int &carry)
    {
        uint64_t res = opa + opb;
        if (res < opa || res < opb)
            ++carry;
        return res;
    }

    /// Multiply two 64-bit values (opa * opb), returning the 128-bit
    /// product in res_hi and res_lo.
    inline void
    mul128(uint64_t opa, uint64_t opb, uint64_t &res_hi, uint64_t &res_lo)
    {
        // do a 64x64 --> 128 multiply using four 32x32 --> 64 multiplies
        uint64_t opa_hi = bits(opa, 63, 32);
        uint64_t opa_lo = bits(opa, 31, 0);
        uint64_t opb_hi = bits(opb, 63, 32);
        uint64_t opb_lo = bits(opb, 31, 0);

        res_lo = opa_lo * opb_lo;

        // The middle partial products logically belong in bit
        // positions 95 to 32.  Thus the lower 32 bits of each product
        // sum into the upper 32 bits of the low result, while the
        // upper 32 sum into the low 32 bits of the upper result.
        uint64_t partial1 = opa_hi * opb_lo;
        uint64_t partial2 = opa_lo * opb_hi;

        uint64_t partial1_lo = bits(partial1, 31, 0) << 32;
        uint64_t partial1_hi = bits(partial1, 63, 32);
        uint64_t partial2_lo = bits(partial2, 31, 0) << 32;
        uint64_t partial2_hi = bits(partial2, 63, 32);

        // Add partial1_lo and partial2_lo to res_lo, keeping track
        // of any carries out
        int carry_out = 0;
        res_lo = addc(partial1_lo, res_lo, carry_out);
        res_lo = addc(partial2_lo, res_lo, carry_out);

        // Now calculate the high 64 bits...
        res_hi = (opa_hi * opb_hi) + partial1_hi + partial2_hi + carry_out;
    }

    /// Map 8-bit S-floating exponent to 11-bit T-floating exponent.
    /// See Table 2-2 of Alpha AHB.
    inline int
    map_s(int old_exp)
    {
        int hibit = bits(old_exp, 7, 7);
        int lobits = bits(old_exp, 6, 0);

        if (hibit == 1) {
            return (lobits == 0x7f) ? 0x7ff : (0x400 | lobits);
        }
        else {
            return (lobits == 0) ? 0 : (0x380 | lobits);
        }
    }

    /// Convert a 32-bit S-floating value to the equivalent 64-bit
    /// representation to be stored in an FP reg.
    inline uint64_t
    s_to_t(uint32_t s_val)
    {
        uint64_t tmp = s_val;
        return (bits(tmp, 31, 31) << 63 // sign bit
                | (uint64_t)map_s(bits(tmp, 30, 23)) << 52 // exponent
                | bits(tmp, 22, 0) << 29); // fraction
    }

    /// Convert a 64-bit T-floating value to the equivalent 32-bit
    /// S-floating representation to be stored in memory.
    inline int32_t
    t_to_s(uint64_t t_val)
    {
        return (bits(t_val, 63, 62) << 30   // sign bit & hi exp bit
                | bits(t_val, 58, 29));     // rest of exp & fraction
    }

// LoadAddress::lda([' Ra = Rb + disp; '],{})

    Fault Lda::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         Ra = Rb + disp; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadAddress::ldah([' Ra = Rb + (disp << 16); '],{})

    Fault Ldah::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         Ra = Rb + (disp << 16); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldbu([' Ra_uq = Mem_ub; '],{})

    Fault Ldbu::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint8_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldbu::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldbu::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint8_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldbu::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint8_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldwu([' Ra_uq = Mem_uw; '],{})

    Fault Ldwu::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint16_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldwu::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldwu::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint16_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldwu::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint16_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldq_u([' Ra = Mem_uq; '],{'ea_code': ' EA = (Rb + disp) & ~7; '})

    Fault Ldq_u::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldq_u::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldq_u::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldq_u::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldt([' Fa = Mem_df; '],{})

    Fault Ldt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t Rb = 0;
double Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Fa = Mem; ;
        }

        if (fault == NoFault) {
            
        {
            double final_val = Fa;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldt::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldt::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
double Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldt::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Fa = Mem; ;
        }

        if (fault == NoFault) {
            
        {
            double final_val = Fa;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldl_l([' Ra_sl = Mem_sl; '],{'mem_flags': 'LLSC'})

    Fault Ldl_l::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
uint64_t Rb = 0;
int32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldl_l::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldl_l::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
int32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldl_l::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrNop::ldq_l([' Ra_uq = Mem_uq; '],{'mem_flags': 'LLSC'})

    Fault Ldq_l::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldq_l::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldq_l::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldq_l::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// LoadOrPrefetch::ldl([' Ra_sl = Mem_sl; '],{})

    Fault Ldl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
uint64_t Rb = 0;
int32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldl::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldl::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
int32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldl::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault LdlPrefetch::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA M5_VAR_USED;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        warn_once("Prefetch instructions in Alpha do not do anything\n");
        if (fault == NoFault) {
            ;;
        }

        return NoFault;
    }

    Fault LdlPrefetch::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault LdlPrefetch::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("initiateAcc undefined: Misc instruction does not support split "
             "access method!");
        return NoFault;
    }

    Fault LdlPrefetch::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("completeAcc undefined: Misc instruction does not support split "
             "access method!");

        return NoFault;
    }

// LoadOrPrefetch::ldq([' Ra_uq = Mem_uq; '],{'pf_flags': 'EVICT_NEXT'})

    Fault Ldq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Ldq::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Ldq::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Ldq::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault LdqPrefetch::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA M5_VAR_USED;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        warn_once("Prefetch instructions in Alpha do not do anything\n");
        if (fault == NoFault) {
            ;;
        }

        return NoFault;
    }

    Fault LdqPrefetch::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault LdqPrefetch::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("initiateAcc undefined: Misc instruction does not support split "
             "access method!");
        return NoFault;
    }

    Fault LdqPrefetch::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("completeAcc undefined: Misc instruction does not support split "
             "access method!");

        return NoFault;
    }

// LoadOrPrefetch::lds([' Fa_uq = s_to_t(Mem_ul); '],{'pf_flags': 'PF_EXCLUSIVE', 'inst_flags': 'IsFloating'})

    Fault Lds::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Fa = s_to_t(Mem); ;
        }

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Lds::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Lds::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Lds::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint32_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Fa = s_to_t(Mem); ;
        }

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault LdsPrefetch::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA M5_VAR_USED;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        warn_once("Prefetch instructions in Alpha do not do anything\n");
        if (fault == NoFault) {
            ;;
        }

        return NoFault;
    }

    Fault LdsPrefetch::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault LdsPrefetch::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("initiateAcc undefined: Misc instruction does not support split "
             "access method!");
        return NoFault;
    }

    Fault LdsPrefetch::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("completeAcc undefined: Misc instruction does not support split "
             "access method!");

        return NoFault;
    }

// Store::stb([' Mem_ub = Ra<7:0>; '],{})

    Fault Stb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint8_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 7, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stb::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stb::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint8_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 7, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stb::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::stw([' Mem_uw = Ra<15:0>; '],{})

    Fault Stw::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint16_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 15, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stw::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stw::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint16_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 15, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stw::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::stl([' Mem_ul = Ra<31:0>; '],{})

    Fault Stl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stl::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stl::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stl::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::stq([' Mem_uq = Ra_uq; '],{})

    Fault Stq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stq::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stq::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stq::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::stq_u([' Mem_uq = Ra_uq; ', ' EA = (Rb + disp) & ~7; '],{})

    Fault Stq_u::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stq_u::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stq_u::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stq_u::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::sts([' Mem_ul = t_to_s(Fa_uq); '],{})

    Fault Sts::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = t_to_s(Fa); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Sts::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Sts::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = t_to_s(Fa); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Sts::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::stt([' Mem_df = Fa; '],{})

    Fault Stt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t Rb = 0;
double Mem = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Fa; ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Stt::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stt::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t Rb = 0;
double Mem = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Fa; ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stt::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// StoreCond::stl_c([' Mem_ul = Ra<31:0>; ', '\n                        uint64_t tmp = write_result;\n                        // see stq_c\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            xc->setStCondFailures(0);\n                        }\n                    '],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    Fault Stl_c::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        uint64_t write_result = 0;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, &write_result);
        }

        if (fault == NoFault) {
            
                        uint64_t tmp = write_result;
                        // see stq_c
                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;
                        if (tmp == 1) {
                            xc->setStCondFailures(0);
                        }
                    ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Stl_c::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stl_c::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stl_c::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
;

        uint64_t write_result = pkt->req->getExtraData();

        if (fault == NoFault) {
            
                        uint64_t tmp = write_result;
                        // see stq_c
                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;
                        if (tmp == 1) {
                            xc->setStCondFailures(0);
                        }
                    ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// StoreCond::stq_c([' Mem_uq = Ra; ', "\n                        uint64_t tmp = write_result;\n                        // If the write operation returns 0 or 1, then\n                        // this was a conventional store conditional,\n                        // and the value indicates the success/failure\n                        // of the operation.  If another value is\n                        // returned, then this was a Turbolaser\n                        // mailbox access, and we don't update the\n                        // result register at all.\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            // clear failure counter... this is\n                            // non-architectural and for debugging\n                            // only.\n                            xc->setStCondFailures(0);\n                        }\n                    "],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    Fault Stq_c::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        uint64_t write_result = 0;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, &write_result);
        }

        if (fault == NoFault) {
            
                        uint64_t tmp = write_result;
                        // If the write operation returns 0 or 1, then
                        // this was a conventional store conditional,
                        // and the value indicates the success/failure
                        // of the operation.  If another value is
                        // returned, then this was a Turbolaser
                        // mailbox access, and we don't update the
                        // result register at all.
                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;
                        if (tmp == 1) {
                            // clear failure counter... this is
                            // non-architectural and for debugging
                            // only.
                            xc->setStCondFailures(0);
                        }
                    ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Stq_c::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Stq_c::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = Rb + disp; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Stq_c::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
;

        uint64_t write_result = pkt->req->getExtraData();

        if (fault == NoFault) {
            
                        uint64_t tmp = write_result;
                        // If the write operation returns 0 or 1, then
                        // this was a conventional store conditional,
                        // and the value indicates the success/failure
                        // of the operation.  If another value is
                        // returned, then this was a Turbolaser
                        // mailbox access, and we don't update the
                        // result register at all.
                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;
                        if (tmp == 1) {
                            // clear failure counter... this is
                            // non-architectural and for debugging
                            // only.
                            xc->setStCondFailures(0);
                        }
                    ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::addl([' Rc_sl = Ra_sl + Rb_or_imm_sl; '],{})

    Fault Addl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra + Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AddlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra + imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::addlv(['\n                int32_t tmp  = Ra_sl + Rb_or_imm_sl;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra_sl<31:> == Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    Fault Addlv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int32_t tmp  = Ra + Rb;
                // signed overflow occurs when operands have same sign
                // and sign of result does not match.
                if (bits(Ra, 31, 31) == bits(Rb, 31, 31) && bits(tmp, 31, 31) != bits(Ra, 31, 31))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AddlvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int32_t tmp  = Ra + imm;
                // signed overflow occurs when operands have same sign
                // and sign of result does not match.
                if (bits(Ra, 31, 31) == bits(imm, 31, 31) && bits(tmp, 31, 31) != bits(Ra, 31, 31))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s4addl([' Rc_sl = (Ra_sl << 2) + Rb_or_imm_sl; '],{})

    Fault S4addl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 2) + Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S4addlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 2) + imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s8addl([' Rc_sl = (Ra_sl << 3) + Rb_or_imm_sl; '],{})

    Fault S8addl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 3) + Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S8addlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 3) + imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::addq([' Rc = Ra + Rb_or_imm; '],{})

    Fault Addq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra + Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AddqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra + imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::addqv(['\n                uint64_t tmp = Ra + Rb_or_imm;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra<63:> == Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    Fault Addqv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                uint64_t tmp = Ra + Rb;
                // signed overflow occurs when operands have same sign
                // and sign of result does not match.
                if (bits(Ra, 63, 63) == bits(Rb, 63, 63) && bits(tmp, 63, 63) != bits(Ra, 63, 63))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AddqvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                uint64_t tmp = Ra + imm;
                // signed overflow occurs when operands have same sign
                // and sign of result does not match.
                if (bits(Ra, 63, 63) == bits(imm, 63, 63) && bits(tmp, 63, 63) != bits(Ra, 63, 63))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s4addq([' Rc = (Ra << 2) + Rb_or_imm; '],{})

    Fault S4addq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 2) + Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S4addqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 2) + imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s8addq([' Rc = (Ra << 3) + Rb_or_imm; '],{})

    Fault S8addq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 3) + Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S8addqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 3) + imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::subl([' Rc_sl = Ra_sl - Rb_or_imm_sl; '],{})

    Fault Subl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra - Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SublImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra - imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::sublv(['\n                int32_t tmp  = Ra_sl - Rb_or_imm_sl;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra_sl<31:> != Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    Fault Sublv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int32_t tmp  = Ra - Rb;
                // signed overflow detection is same as for add,
                // except we need to look at the *complemented*
                // sign bit of the subtrahend (Rb), i.e., if the initial
                // signs are the *same* then no overflow can occur
                if (bits(Ra, 31, 31) != bits(Rb, 31, 31) && bits(tmp, 31, 31) != bits(Ra, 31, 31))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SublvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int32_t tmp  = Ra - imm;
                // signed overflow detection is same as for add,
                // except we need to look at the *complemented*
                // sign bit of the subtrahend (Rb), i.e., if the initial
                // signs are the *same* then no overflow can occur
                if (bits(Ra, 31, 31) != bits(imm, 31, 31) && bits(tmp, 31, 31) != bits(Ra, 31, 31))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s4subl([' Rc_sl = (Ra_sl << 2) - Rb_or_imm_sl; '],{})

    Fault S4subl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 2) - Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S4sublImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 2) - imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s8subl([' Rc_sl = (Ra_sl << 3) - Rb_or_imm_sl; '],{})

    Fault S8subl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 3) - Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S8sublImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 3) - imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::subq([' Rc = Ra - Rb_or_imm; '],{})

    Fault Subq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra - Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SubqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra - imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::subqv(['\n                uint64_t tmp  = Ra - Rb_or_imm;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra<63:> != Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    Fault Subqv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                uint64_t tmp  = Ra - Rb;
                // signed overflow detection is same as for add,
                // except we need to look at the *complemented*
                // sign bit of the subtrahend (Rb), i.e., if the initial
                // signs are the *same* then no overflow can occur
                if (bits(Ra, 63, 63) != bits(Rb, 63, 63) && bits(tmp, 63, 63) != bits(Ra, 63, 63))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SubqvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                uint64_t tmp  = Ra - imm;
                // signed overflow detection is same as for add,
                // except we need to look at the *complemented*
                // sign bit of the subtrahend (Rb), i.e., if the initial
                // signs are the *same* then no overflow can occur
                if (bits(Ra, 63, 63) != bits(imm, 63, 63) && bits(tmp, 63, 63) != bits(Ra, 63, 63))
                    fault = new IntegerOverflowFault;
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s4subq([' Rc = (Ra << 2) - Rb_or_imm; '],{})

    Fault S4subq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 2) - Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S4subqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 2) - imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::s8subq([' Rc = (Ra << 3) - Rb_or_imm; '],{})

    Fault S8subq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra << 3) - Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault S8subqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra << 3) - imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmpeq([' Rc = (Ra == Rb_or_imm); '],{})

    Fault Cmpeq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra == Rb); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpeqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra == imm); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmple([' Rc = (Ra_sq <= Rb_or_imm_sq); '],{})

    Fault Cmple::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
int64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <= Rb); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpleImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra <= imm); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmplt([' Rc = (Ra_sq <  Rb_or_imm_sq); '],{})

    Fault Cmplt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
int64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <  Rb); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpltImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra <  imm); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmpule([' Rc = (Ra_uq <= Rb_or_imm_uq); '],{})

    Fault Cmpule::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <= Rb); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpuleImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra <= imm); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmpult([' Rc = (Ra_uq <  Rb_or_imm_uq); '],{})

    Fault Cmpult::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <  Rb); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpultImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra <  imm); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmpbge(['\n                int hi = 7;\n                int lo = 0;\n                uint64_t tmp = 0;\n                for (int i = 0; i < 8; ++i) {\n                    tmp |= (Ra_uq<hi:lo> >= Rb_or_imm_uq<hi:lo>) << i;\n                    hi += 8;\n                    lo += 8;\n                }\n                Rc = tmp;\n            '],{})

    Fault Cmpbge::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int hi = 7;
                int lo = 0;
                uint64_t tmp = 0;
                for (int i = 0; i < 8; ++i) {
                    tmp |= (bits(Ra, hi, lo) >= bits(Rb, hi, lo)) << i;
                    hi += 8;
                    lo += 8;
                }
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmpbgeImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int hi = 7;
                int lo = 0;
                uint64_t tmp = 0;
                for (int i = 0; i < 8; ++i) {
                    tmp |= (bits(Ra, hi, lo) >= bits(imm, hi, lo)) << i;
                    hi += 8;
                    lo += 8;
                }
                Rc = tmp;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::and([' Rc = Ra & Rb_or_imm; '],{})

    Fault And::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AndImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::bic([' Rc = Ra & ~Rb_or_imm; '],{})

    Fault Bic::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & ~Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault BicImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & ~imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::bis([' Rc = Ra | Rb_or_imm; '],{})

    Fault Bis::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra | Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault BisImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra | imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::ornot([' Rc = Ra | ~Rb_or_imm; '],{})

    Fault Ornot::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra | ~Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault OrnotImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra | ~imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::xor([' Rc = Ra ^ Rb_or_imm; '],{})

    Fault Xor::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra ^ Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault XorImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra ^ imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::eqv([' Rc = Ra ^ ~Rb_or_imm; '],{})

    Fault Eqv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra ^ ~Rb; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault EqvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra ^ ~imm; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovlbs([' Rc = ((Ra & 1) == 1) ? Rb_or_imm : Rc; '],{})

    Fault Cmovlbs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = ((Ra & 1) == 1) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovlbsImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = ((Ra & 1) == 1) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovlbc([' Rc = ((Ra & 1) == 0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovlbc::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = ((Ra & 1) == 0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovlbcImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = ((Ra & 1) == 0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmoveq([' Rc = (Ra == 0) ? Rb_or_imm : Rc; '],{})

    Fault Cmoveq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra == 0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmoveqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra == 0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovne([' Rc = (Ra != 0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovne::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra != 0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovneImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra != 0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovlt([' Rc = (Ra_sq <  0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovlt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra <  0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovltImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <  0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovge([' Rc = (Ra_sq >= 0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovge::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra >= 0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovgeImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra >= 0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovle([' Rc = (Ra_sq <= 0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovle::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra <= 0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovleImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra <= 0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cmovgt([' Rc = (Ra_sq >  0) ? Rb_or_imm : Rc; '],{})

    Fault Cmovgt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
Rc = xc->readIntRegOperand(this, 2);
;
         Rc = (Ra >  0) ? Rb : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault CmovgtImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rc = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra >  0) ? imm : Rc; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::amask([' Rc = Rb_or_imm & ~ULL(0x17); '],{})

    Fault Amask::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         Rc = Rb & ~ULL(0x17); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault AmaskImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rc = 0;
;
        ;
         Rc = imm & ~ULL(0x17); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::implver([' Rc = FullSystem ? 1 : 2 '],{})

    Fault Implver::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rc = 0;
;
        ;
         Rc = FullSystem ? 1 : 2 ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// WarnUnimpl::eleven25(([], {}))

// Unknown::unknown(([], {}))

// IntegerOperate::sll([' Rc = Ra << Rb_or_imm<5:0>; '],{})

    Fault Sll::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra << bits(Rb, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SllImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra << bits(imm, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::srl([' Rc = Ra_uq >> Rb_or_imm<5:0>; '],{})

    Fault Srl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra >> bits(Rb, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SrlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra >> bits(imm, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::sra([' Rc = Ra_sq >> Rb_or_imm<5:0>; '],{})

    Fault Sra::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra >> bits(Rb, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SraImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra >> bits(imm, 5, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskbl([' Rc = Ra & ~(mask( 8) << (Rb_or_imm<2:0> * 8)); '],{})

    Fault Mskbl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & ~(mask( 8) << (bits(Rb, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskblImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & ~(mask( 8) << (bits(imm, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskwl([' Rc = Ra & ~(mask(16) << (Rb_or_imm<2:0> * 8)); '],{})

    Fault Mskwl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & ~(mask(16) << (bits(Rb, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskwlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & ~(mask(16) << (bits(imm, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskll([' Rc = Ra & ~(mask(32) << (Rb_or_imm<2:0> * 8)); '],{})

    Fault Mskll::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & ~(mask(32) << (bits(Rb, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskllImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & ~(mask(32) << (bits(imm, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskql([' Rc = Ra & ~(mask(64) << (Rb_or_imm<2:0> * 8)); '],{})

    Fault Mskql::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra & ~(mask(64) << (bits(Rb, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskqlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra & ~(mask(64) << (bits(imm, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskwh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;\n            '],{})

    Fault Mskwh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskwhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::msklh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;\n            '],{})

    Fault Msklh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MsklhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mskqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;\n            '],{})

    Fault Mskqh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MskqhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extbl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))< 7:0>; '],{})

    Fault Extbl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits((Ra >> (bits(Rb, 2, 0) * 8)), 7, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtblImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits((Ra >> (bits(imm, 2, 0) * 8)), 7, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extwl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<15:0>; '],{})

    Fault Extwl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits((Ra >> (bits(Rb, 2, 0) * 8)), 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtwlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits((Ra >> (bits(imm, 2, 0) * 8)), 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extll([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<31:0>; '],{})

    Fault Extll::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits((Ra >> (bits(Rb, 2, 0) * 8)), 31, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtllImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits((Ra >> (bits(imm, 2, 0) * 8)), 31, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extql([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8)); '],{})

    Fault Extql::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = (Ra >> (bits(Rb, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtqlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = (Ra >> (bits(imm, 2, 0) * 8)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extwh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<15:0>; '],{})

    Fault Extwh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                Rc = bits((Ra << bits((64 - (bits(Rb, 2, 0) * 8)), 5, 0)), 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtwhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                Rc = bits((Ra << bits((64 - (bits(imm, 2, 0) * 8)), 5, 0)), 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extlh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<31:0>; '],{})

    Fault Extlh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                Rc = bits((Ra << bits((64 - (bits(Rb, 2, 0) * 8)), 5, 0)), 31, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtlhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                Rc = bits((Ra << bits((64 - (bits(imm, 2, 0) * 8)), 5, 0)), 31, 0); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::extqh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>); '],{})

    Fault Extqh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                Rc = (Ra << bits((64 - (bits(Rb, 2, 0) * 8)), 5, 0)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ExtqhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                Rc = (Ra << bits((64 - (bits(imm, 2, 0) * 8)), 5, 0)); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::insbl([' Rc = Ra< 7:0> << (Rb_or_imm<2:0> * 8); '],{})

    Fault Insbl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits(Ra, 7, 0) << (bits(Rb, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InsblImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits(Ra, 7, 0) << (bits(imm, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::inswl([' Rc = Ra<15:0> << (Rb_or_imm<2:0> * 8); '],{})

    Fault Inswl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits(Ra, 15, 0) << (bits(Rb, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InswlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits(Ra, 15, 0) << (bits(imm, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::insll([' Rc = Ra<31:0> << (Rb_or_imm<2:0> * 8); '],{})

    Fault Insll::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = bits(Ra, 31, 0) << (bits(Rb, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InsllImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = bits(Ra, 31, 0) << (bits(imm, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::insql([' Rc = Ra       << (Rb_or_imm<2:0> * 8); '],{})

    Fault Insql::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra       << (bits(Rb, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InsqlImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra       << (bits(imm, 2, 0) * 8); ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::inswh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<15:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    Fault Inswh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc = bv ? (bits(Ra, 15, 0) >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InswhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc = bv ? (bits(Ra, 15, 0) >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::inslh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<31:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    Fault Inslh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc = bv ? (bits(Ra, 31, 0) >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InslhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc = bv ? (bits(Ra, 31, 0) >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::insqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq       >> (64 - 8 * bv)) : 0;\n            '],{})

    Fault Insqh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                int bv = bits(Rb, 2, 0);
                Rc = bv ? (Ra       >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault InsqhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int bv = bits(imm, 2, 0);
                Rc = bv ? (Ra       >> (64 - 8 * bv)) : 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::zap(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    Fault Zap::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                uint64_t zapmask = 0;
                for (int i = 0; i < 8; ++i) {
                    if (bits(Rb, i, i))
                        zapmask |= (mask(8) << (i * 8));
                }
                Rc = Ra & ~zapmask;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ZapImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                uint64_t zapmask = 0;
                for (int i = 0; i < 8; ++i) {
                    if (bits(imm, i, i))
                        zapmask |= (mask(8) << (i * 8));
                }
                Rc = Ra & ~zapmask;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::zapnot(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (!Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    Fault Zapnot::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                uint64_t zapmask = 0;
                for (int i = 0; i < 8; ++i) {
                    if (!bits(Rb, i, i))
                        zapmask |= (mask(8) << (i * 8));
                }
                Rc = Ra & ~zapmask;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault ZapnotImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                uint64_t zapmask = 0;
                for (int i = 0; i < 8; ++i) {
                    if (!bits(imm, i, i))
                        zapmask |= (mask(8) << (i * 8));
                }
                Rc = Ra & ~zapmask;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::mull([' Rc_sl = Ra_sl * Rb_or_imm_sl; ', 'IntMultOp'],{})

    Fault Mull::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc = Ra * Rb; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MullImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc = Ra * imm; ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mulq([' Rc    = Ra    * Rb_or_imm;    ', 'IntMultOp'],{})

    Fault Mulq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         Rc    = Ra    * Rb;    ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MulqImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Rc    = Ra    * imm;    ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::umulh(['\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                Rc = hi;\n            ', 'IntMultOp'],{})

    Fault Umulh::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                uint64_t hi, lo;
                mul128(Ra, Rb, hi, lo);
                Rc = hi;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault UmulhImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                uint64_t hi, lo;
                mul128(Ra, imm, hi, lo);
                Rc = hi;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mullv(['\n                // 32-bit multiply with trap on overflow\n                int64_t Rax = Ra_sl;    // sign extended version of Ra_sl\n                int64_t Rbx = Rb_or_imm_sl;\n                int64_t tmp = Rax * Rbx;\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = tmp<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp<31:0>;\n            ', 'IntMultOp'],{})

    Fault Mullv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rb = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                // 32-bit multiply with trap on overflow
                int64_t Rax = Ra;    // sign extended version of Ra
                int64_t Rbx = Rb;
                int64_t tmp = Rax * Rbx;
                // To avoid overflow, all the upper 32 bits must match
                // the sign bit of the lower 32.  We code this as
                // checking the upper 33 bits for all 0s or all 1s.
                uint64_t sign_bits = bits(tmp, 63, 31);
                if (sign_bits != 0 && sign_bits != mask(33))
                    fault = new IntegerOverflowFault;
                Rc = bits(tmp, 31, 0);
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MullvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int32_t Ra = 0;
int32_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                // 32-bit multiply with trap on overflow
                int64_t Rax = Ra;    // sign extended version of Ra
                int64_t Rbx = imm;
                int64_t tmp = Rax * Rbx;
                // To avoid overflow, all the upper 32 bits must match
                // the sign bit of the lower 32.  We code this as
                // checking the upper 33 bits for all 0s or all 1s.
                uint64_t sign_bits = bits(tmp, 63, 31);
                if (sign_bits != 0 && sign_bits != mask(33))
                    fault = new IntegerOverflowFault;
                Rc = bits(tmp, 31, 0);
            ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::mulqv(['\n                // 64-bit multiply with trap on overflow\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                // all the upper 64 bits must match the sign bit of\n                // the lower 64\n                if (!((hi == 0 && lo<63:> == 0) ||\n                      (hi == mask(64) && lo<63:> == 1)))\n                    fault = new IntegerOverflowFault;\n                Rc = lo;\n            ', 'IntMultOp'],{})

    Fault Mulqv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                // 64-bit multiply with trap on overflow
                uint64_t hi, lo;
                mul128(Ra, Rb, hi, lo);
                // all the upper 64 bits must match the sign bit of
                // the lower 64
                if (!((hi == 0 && bits(lo, 63, 63) == 0) ||
                      (hi == mask(64) && bits(lo, 63, 63) == 1)))
                    fault = new IntegerOverflowFault;
                Rc = lo;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault MulqvImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                // 64-bit multiply with trap on overflow
                uint64_t hi, lo;
                mul128(Ra, imm, hi, lo);
                // all the upper 64 bits must match the sign bit of
                // the lower 64
                if (!((hi == 0 && bits(lo, 63, 63) == 0) ||
                      (hi == mask(64) && bits(lo, 63, 63) == 1)))
                    fault = new IntegerOverflowFault;
                Rc = lo;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::sextb([' Rc_sb = Rb_or_imm< 7:0>; '],{})

    Fault Sextb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
int8_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         Rc = bits(Rb, 7, 0); ;

        if (fault == NoFault) {
            
        
        {
            int8_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SextbImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int8_t Rc = 0;
;
        ;
         Rc = bits(imm, 7, 0); ;

        if (fault == NoFault) {
            
        
        {
            int8_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::sextw([' Rc_sw = Rb_or_imm<15:0>; '],{})

    Fault Sextw::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
int16_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         Rc = bits(Rb, 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            int16_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault SextwImm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int16_t Rc = 0;
;
        ;
         Rc = bits(imm, 15, 0); ;

        if (fault == NoFault) {
            
        
        {
            int16_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::ctpop(['\n                             uint64_t count = 0;\n                             for (int i = 0; Rb<63:i>; ++i) {\n                                 if (Rb<i:i> == 0x1)\n                                     ++count;\n                             }\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    Fault Ctpop::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             uint64_t count = 0;
                             for (int i = 0; bits(Rb, 63, i); ++i) {
                                 if (bits(Rb, i, i) == 0x1)
                                     ++count;
                             }
                             Rc = count;
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::perr(['\n                             uint64_t temp = 0;\n                             int hi = 7;\n                             int lo = 0;\n                             for (int i = 0; i < 8; ++i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp += (ra_ub >= rb_ub) ? \n                                         (ra_ub - rb_ub) : (rb_ub - ra_ub);\n                                 hi += 8;\n                                 lo += 8;\n                             }\n                             Rc = temp;\n                           '],{})

    Fault Perr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 7;
                             int lo = 0;
                             for (int i = 0; i < 8; ++i) {
                                 uint8_t ra_ub = bits(Ra, hi, lo);
                                 uint8_t rb_ub = bits(Rb, hi, lo);
                                 temp += (ra_ub >= rb_ub) ? 
                                         (ra_ub - rb_ub) : (rb_ub - ra_ub);
                                 hi += 8;
                                 lo += 8;
                             }
                             Rc = temp;
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::ctlz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (temp<63:32>) temp >>= 32; else count += 32;\n                             if (temp<31:16>) temp >>= 16; else count += 16;\n                             if (temp<15:8>) temp >>= 8; else count += 8;\n                             if (temp<7:4>) temp >>= 4; else count += 4;\n                             if (temp<3:2>) temp >>= 2; else count += 2;\n                             if (temp<1:1>) temp >>= 1; else count += 1;\n                             if ((temp<0:0>) != 0x1) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    Fault Ctlz::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             uint64_t count = 0;
                             uint64_t temp = Rb;
                             if (bits(temp, 63, 32)) temp >>= 32; else count += 32;
                             if (bits(temp, 31, 16)) temp >>= 16; else count += 16;
                             if (bits(temp, 15, 8)) temp >>= 8; else count += 8;
                             if (bits(temp, 7, 4)) temp >>= 4; else count += 4;
                             if (bits(temp, 3, 2)) temp >>= 2; else count += 2;
                             if (bits(temp, 1, 1)) temp >>= 1; else count += 1;
                             if ((bits(temp, 0, 0)) != 0x1) count += 1;
                             Rc = count;
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::cttz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (!(temp<31:0>)) { temp >>= 32; count += 32; }\n                             if (!(temp<15:0>)) { temp >>= 16; count += 16; }\n                             if (!(temp<7:0>)) { temp >>= 8; count += 8; }\n                             if (!(temp<3:0>)) { temp >>= 4; count += 4; }\n                             if (!(temp<1:0>)) { temp >>= 2; count += 2; }\n                             if (!(temp<0:0> & ULL(0x1))) { \n                                 temp >>= 1; count += 1; \n                             }\n                             if (!(temp<0:0> & ULL(0x1))) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    Fault Cttz::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             uint64_t count = 0;
                             uint64_t temp = Rb;
                             if (!(bits(temp, 31, 0))) { temp >>= 32; count += 32; }
                             if (!(bits(temp, 15, 0))) { temp >>= 16; count += 16; }
                             if (!(bits(temp, 7, 0))) { temp >>= 8; count += 8; }
                             if (!(bits(temp, 3, 0))) { temp >>= 4; count += 4; }
                             if (!(bits(temp, 1, 0))) { temp >>= 2; count += 2; }
                             if (!(bits(temp, 0, 0) & ULL(0x1))) { 
                                 temp >>= 1; count += 1; 
                             }
                             if (!(bits(temp, 0, 0) & ULL(0x1))) count += 1;
                             Rc = count;
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::unpkbw([' \n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<15:8> << 16)\n                                   | (Rb_uq<23:16> << 32)\n                                   | (Rb_uq<31:24> << 48));\n                           ', 'IntAluOp'],{})

    Fault Unpkbw::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         
                             Rc = (bits(Rb, 7, 0)
                                   | (bits(Rb, 15, 8) << 16)
                                   | (bits(Rb, 23, 16) << 32)
                                   | (bits(Rb, 31, 24) << 48));
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::unpkbl(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<15:8> << 32));\n                           ', 'IntAluOp'],{})

    Fault Unpkbl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             Rc = (bits(Rb, 7, 0) | (bits(Rb, 15, 8) << 32));
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::pkwb(['\n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<23:16> << 8)\n                                   | (Rb_uq<39:32> << 16)\n                                   | (Rb_uq<55:48> << 24));\n                           ', 'IntAluOp'],{})

    Fault Pkwb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             Rc = (bits(Rb, 7, 0)
                                   | (bits(Rb, 23, 16) << 8)
                                   | (bits(Rb, 39, 32) << 16)
                                   | (bits(Rb, 55, 48) << 24));
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::pklb(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<39:32> << 8));\n                           ', 'IntAluOp'],{})

    Fault Pklb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                             Rc = (bits(Rb, 7, 0) | (bits(Rb, 39, 32) << 8));
                           ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::minsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb < rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Minsb8::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 56;
                             for (int i = 7; i >= 0; --i) {
                                 int8_t ra_sb = bits(Ra, hi, lo);
                                 int8_t rb_sb = bits(Rb, hi, lo);
                                 temp = ((temp << 8) 
                                         | ((ra_sb < rb_sb) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 8;
                                 lo -= 8;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::minsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Minsw4::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 48;
                             for (int i = 3; i >= 0; --i) {
                                 int16_t ra_sw = bits(Ra, hi, lo);
                                 int16_t rb_sw = bits(Rb, hi, lo);
                                 temp = ((temp << 16) 
                                         | ((ra_sw < rb_sw) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 16;
                                 lo -= 16;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::minub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub < rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Minub8::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 56;
                             for (int i = 7; i >= 0; --i) {
                                 uint8_t ra_ub = bits(Ra, hi, lo);
                                 uint8_t rb_ub = bits(Rb, hi, lo);
                                 temp = ((temp << 8) 
                                         | ((ra_ub < rb_ub) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 8;
                                 lo -= 8;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::minuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_sw = Ra_uq<hi:lo>;\n                                 uint16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Minuw4::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 48;
                             for (int i = 3; i >= 0; --i) {
                                 uint16_t ra_sw = bits(Ra, hi, lo);
                                 uint16_t rb_sw = bits(Rb, hi, lo);
                                 temp = ((temp << 16) 
                                         | ((ra_sw < rb_sw) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 16;
                                 lo -= 16;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::maxub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub > rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Maxub8::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 56;
                             for (int i = 7; i >= 0; --i) {
                                 uint8_t ra_ub = bits(Ra, hi, lo);
                                 uint8_t rb_ub = bits(Rb, hi, lo);
                                 temp = ((temp << 8) 
                                         | ((ra_ub > rb_ub) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 8;
                                 lo -= 8;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::maxuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_uw = Ra_uq<hi:lo>;\n                                 uint16_t rb_uw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_uw > rb_uw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Maxuw4::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 48;
                             for (int i = 3; i >= 0; --i) {
                                 uint16_t ra_uw = bits(Ra, hi, lo);
                                 uint16_t rb_uw = bits(Rb, hi, lo);
                                 temp = ((temp << 16) 
                                         | ((ra_uw > rb_uw) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 16;
                                 lo -= 16;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::maxsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb > rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Maxsb8::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 56;
                             for (int i = 7; i >= 0; --i) {
                                 int8_t ra_sb = bits(Ra, hi, lo);
                                 int8_t rb_sb = bits(Rb, hi, lo);
                                 temp = ((temp << 8) 
                                         | ((ra_sb > rb_sb) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 8;
                                 lo -= 8;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// IntegerOperate::maxsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw > rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    Fault Maxsw4::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Rc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
        
                             uint64_t temp = 0;
                             int hi = 63;
                             int lo = 48;
                             for (int i = 3; i >= 0; --i) {
                                 int16_t ra_sw = bits(Ra, hi, lo);
                                 int16_t rb_sw = bits(Rb, hi, lo);
                                 temp = ((temp << 16) 
                                         | ((ra_sw > rb_sw) ? bits(Ra, hi, lo)
                                                          : bits(Rb, hi, lo)));
                                 hi -= 16;
                                 lo -= 16;
                             }
                             Rc = temp;
                          ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::ftoit([' Rc = Fa_uq; ', 'FloatCvtOp'],{})

    Fault Ftoit::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Rc = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
;
         Rc = Fa; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::ftois([' Rc_sl = t_to_s(Fa_uq); ', 'FloatCvtOp'],{})

    Fault Ftois::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
int32_t Rc = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
;
         Rc = t_to_s(Fa); ;

        if (fault == NoFault) {
            
        
        {
            int32_t final_val = Rc;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CondBranch::beq([' cond = (Ra == 0); '],{})

    Fault Beq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra == 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::bne([' cond = (Ra != 0); '],{})

    Fault Bne::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra != 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::bge([' cond = (Ra_sq >= 0); '],{})

    Fault Bge::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra >= 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::bgt([' cond = (Ra_sq >  0); '],{})

    Fault Bgt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra >  0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::ble([' cond = (Ra_sq <= 0); '],{})

    Fault Ble::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra <= 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::blt([' cond = (Ra_sq < 0); '],{})

    Fault Blt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        int64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Ra < 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::blbc([' cond = ((Ra & 1) == 0); '],{})

    Fault Blbc::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = ((Ra & 1) == 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::blbs([' cond = ((Ra & 1) == 1); '],{})

    Fault Blbs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Ra = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = ((Ra & 1) == 1); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fbeq([' cond = (Fa == 0); '],{})

    Fault Fbeq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa == 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fbne([' cond = (Fa != 0); '],{})

    Fault Fbne::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa != 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fbge([' cond = (Fa >= 0); '],{})

    Fault Fbge::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa >= 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fbgt([' cond = (Fa >  0); '],{})

    Fault Fbgt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa >  0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fble([' cond = (Fa <= 0); '],{})

    Fault Fble::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa <= 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// CondBranch::fblt([' cond = (Fa < 0); '],{})

    Fault Fblt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Fa = xc->readFloatRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
        bool cond;
         cond = (Fa < 0); ;
        if (cond)
            NPC = NPC + disp;
        else
            NPC = NPC;
    ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// UncondBranch::br([],{})

    Fault Br::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
NPC = __parserAutoPCState.npc();
;
        NPC = NPC + disp;
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault BrAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = NPC + disp;
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// UncondBranch::bsr(['IsCall'],{})

    Fault Bsr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
NPC = __parserAutoPCState.npc();
;
        NPC = NPC + disp;
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault BsrAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = NPC + disp;
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// Jump::jmp([],{})

    Fault Jmp::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault JmpAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// Jump::jsr(['IsCall'],{})

    Fault Jsr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault JsrAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// Jump::ret(['IsReturn'],{})

    Fault Ret::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault RetAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// Jump::jsr_coroutine(['IsCall', 'IsReturn'],{})

    Fault Jsr_coroutine::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

    Fault Jsr_coroutineAndLink::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Rb = xc->readIntRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        Ra = NPC & ~3;
NPC = (Rb & ~3) | (NPC & 1);
;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::itofs([' Fc_uq = s_to_t(Ra_ul); ', 'FloatCvtOp'],{})

    Fault Itofs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint32_t Ra = 0;
uint64_t Fc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Fc = s_to_t(Ra); ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::itoft([' Fc_uq = Ra_uq; ', 'FloatCvtOp'],{})

    Fault Itoft::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Ra = 0;
uint64_t Fc = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
         Fc = Ra; ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FailUnimpl::itoff(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::sqrts(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    Fault Sqrts::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
double Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
        
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }
#else

// FloatingPointOperate::sqrts(['\n                        if (Fb_sf < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc_sf = sqrt(Fb_sf);\n                    ', 'FloatSqrtOp'],{})

    Fault Sqrts::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fb = 0;
float Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
        
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }
#endif

// FloatingPointOperate::sqrtt(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    Fault Sqrtt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
double Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
            
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
        
                        if (Fb < 0.0)
                            fault = new ArithmeticFault;
                        Fc = sqrt(Fb);
                    ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FailUnimpl::sqrtfg(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::adds([' Fc = Fa + Fb; '],{})

    Fault Adds::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa + Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa + Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa + Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::subs([' Fc = Fa - Fb; '],{})

    Fault Subs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa - Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa - Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa - Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::muls([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    Fault Muls::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa * Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa * Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa * Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::divs([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    Fault Divs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa / Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa / Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa / Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }
#else

// FloatingPointOperate::adds([' Fc_sf = Fa_sf + Fb_sf; '],{})

    Fault Adds::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fa = 0;
float Fb = 0;
float Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa + Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa + Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa + Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::subs([' Fc_sf = Fa_sf - Fb_sf; '],{})

    Fault Subs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fa = 0;
float Fb = 0;
float Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa - Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa - Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa - Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::muls([' Fc_sf = Fa_sf * Fb_sf; ', 'FloatMultOp'],{})

    Fault Muls::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fa = 0;
float Fb = 0;
float Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa * Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa * Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa * Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::divs([' Fc_sf = Fa_sf / Fb_sf; ', 'FloatDivOp'],{})

    Fault Divs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fa = 0;
float Fb = 0;
float Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa / Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa / Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa / Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }
#endif

// FloatingPointOperate::addt([' Fc = Fa + Fb; '],{})

    Fault Addt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa + Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa + Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa + Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::subt([' Fc = Fa - Fb; '],{})

    Fault Subt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa - Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa - Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa - Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::mult([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    Fault Mult::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa * Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa * Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa * Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::divt([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    Fault Divt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fa / Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fa / Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fa / Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cmpteq([' Fc = (Fa == Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    Fault Cmpteq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
         Fc = (Fa == Fb) ? 2.0 : 0.0; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cmptle([' Fc = (Fa <= Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    Fault Cmptle::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
         Fc = (Fa <= Fb) ? 2.0 : 0.0; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cmptlt([' Fc = (Fa <  Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    Fault Cmptlt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
         Fc = (Fa <  Fb) ? 2.0 : 0.0; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cmptun([' // unordered\n                    Fc = (!(Fa < Fb) && !(Fa == Fb) && !(Fa > Fb)) ? 2.0 : 0.0;\n                ', 'FloatCmpOp'],{})

    Fault Cmptun::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
;
         // unordered
                    Fc = (!(Fa < Fb) && !(Fa == Fb) && !(Fa > Fb)) ? 2.0 : 0.0;
                ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)trunc(Fb); ', 'Chopped'],{})

    Fault CvttqChopped::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
int64_t Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
         Fc = (int64_t)trunc(Fb); ;

        if (fault == NoFault) {
            
        {
            int64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)floor(Fb); ', 'MinusInfinity'],{})

    Fault CvttqMinusInfinity::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
int64_t Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
         Fc = (int64_t)floor(Fb); ;

        if (fault == NoFault) {
            
        {
            int64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::cvttq([' Fc_sq = (int64_t)nearbyint(Fb); '],{})

    Fault Cvttq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
int64_t Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = (int64_t)nearbyint(Fb); ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = (int64_t)nearbyint(Fb); ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = (int64_t)nearbyint(Fb); ;
#endif

        if (fault == NoFault) {
            
        {
            int64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cvtst([' Fc = Fb_sf; '],{})

    Fault Cvtst::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        float Fb = 0;
double Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
         Fc = Fb; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::cvtts([' Fc_sf = Fb; '],{})

    Fault Cvtts::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fb = 0;
float Fc = 0;
;
        Fb = xc->readFloatRegOperand(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// FloatingPointOperate::cvtqs([' Fc_sf = Fb_sq; '],{})

    Fault Cvtqs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        int64_t Fb = 0;
float Fc = 0;
;
        Fb = xc->readFloatRegOperandBits(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc = Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc = Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc = Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            float final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// FloatingPointOperate::cvtqt([' Fc    = Fb_sq; '],{})

    Fault Cvtqt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        if (trappingMode != Imprecise && !warnedOnTrapping) {
            warn("%s: non-standard trapping mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnTrapping = true;
        }

        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        int64_t Fb = 0;
double Fc = 0;
;
        Fb = xc->readFloatRegOperandBits(this, 0);
;
#if USE_FENV
        if (roundingMode == Normal) {
             Fc    = Fb; ;
        } else {
            m5_fesetround(getC99RoundingMode(
                           xc->readMiscReg(MISCREG_FPCR)));
             Fc    = Fb; ;
            m5_fesetround(M5_FE_TONEAREST);
        }
#else
        if (roundingMode != Normal && !warnedOnRounding) {
            warn("%s: non-standard rounding mode not supported",
                 generateDisassembly(0, NULL));
            warnedOnRounding = true;
        }
         Fc    = Fb; ;
#endif

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cvtlq(['\n                Fc_sl = (Fb_uq<63:62> << 30) | Fb_uq<58:29>;\n            '],{})

    Fault Cvtlq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fb = 0;
int32_t Fc = 0;
;
        Fb = xc->readFloatRegOperandBits(this, 0);
;
        
                Fc = (bits(Fb, 63, 62) << 30) | bits(Fb, 58, 29);
            ;

        if (fault == NoFault) {
            
        {
            int32_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cvtql(['\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    Fault Cvtql::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fb = 0;
uint64_t Fc = 0;
;
        Fb = xc->readFloatRegOperandBits(this, 0);
;
        
                Fc = (bits(Fb, 31, 30) << 62) | (bits(Fb, 29, 0) << 29);
            ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cvtqlv(['\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = Fb_uq<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    Fault Cvtqlv::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fb = 0;
uint64_t Fc = 0;
;
        Fb = xc->readFloatRegOperandBits(this, 0);
;
        
                // To avoid overflow, all the upper 32 bits must match
                // the sign bit of the lower 32.  We code this as
                // checking the upper 33 bits for all 0s or all 1s.
                uint64_t sign_bits = bits(Fb, 63, 31);
                if (sign_bits != 0 && sign_bits != mask(33))
                    fault = new IntegerOverflowFault;
                Fc = (bits(Fb, 31, 30) << 62) | (bits(Fb, 29, 0) << 29);
            ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cpys(['  // copy sign\n                Fc_uq = (Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    Fault Cpys::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Fb = 0;
uint64_t Fc = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
Fb = xc->readFloatRegOperandBits(this, 1);
;
          // copy sign
                Fc = (bits(Fa, 63, 63) << 63) | bits(Fb, 62, 0);
            ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cpysn([' // copy sign negated\n                Fc_uq = (~Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    Fault Cpysn::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Fb = 0;
uint64_t Fc = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
Fb = xc->readFloatRegOperandBits(this, 1);
;
         // copy sign negated
                Fc = (~bits(Fa, 63, 63) << 63) | bits(Fb, 62, 0);
            ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::cpyse([' // copy sign and exponent\n                Fc_uq = (Fa_uq<63:52> << 52) | Fb_uq<51:0>;\n            '],{})

    Fault Cpyse::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t Fb = 0;
uint64_t Fc = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
Fb = xc->readFloatRegOperandBits(this, 1);
;
         // copy sign and exponent
                Fc = (bits(Fa, 63, 52) << 52) | bits(Fb, 51, 0);
            ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fc;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmoveq([' Fc = (Fa == 0) ? Fb : Fc; '],{})

    Fault Fcmoveq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa == 0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmovne([' Fc = (Fa != 0) ? Fb : Fc; '],{})

    Fault Fcmovne::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa != 0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmovlt([' Fc = (Fa <  0) ? Fb : Fc; '],{})

    Fault Fcmovlt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa <  0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmovge([' Fc = (Fa >= 0) ? Fb : Fc; '],{})

    Fault Fcmovge::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa >= 0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmovle([' Fc = (Fa <= 0) ? Fb : Fc; '],{})

    Fault Fcmovle::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa <= 0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::fcmovgt([' Fc = (Fa >  0) ? Fb : Fc; '],{})

    Fault Fcmovgt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        double Fa = 0;
double Fb = 0;
double Fc = 0;
;
        Fa = xc->readFloatRegOperand(this, 0);
Fb = xc->readFloatRegOperand(this, 1);
Fc = xc->readFloatRegOperand(this, 2);
;
         Fc = (Fa >  0) ? Fb : Fc; ;

        if (fault == NoFault) {
            
        {
            double final_val = Fc;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperateWithNopCheck::mt_fpcr([' FPCR = Fa_uq; ', 'IsIprAccess'],{})

    Fault Mt_fpcr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t FPCR = 0;
uint64_t Fa = 0;
;
        Fa = xc->readFloatRegOperandBits(this, 0);
;
         FPCR = Fa; ;

        if (fault == NoFault) {
            xc->setMiscRegOperand(this, 0, FPCR);
if (traceData) { traceData->setData(FPCR); };
        }

        return fault;
    }

// BasicOperateWithNopCheck::mf_fpcr([' Fa_uq = FPCR; ', 'IsIprAccess'],{})

    Fault Mf_fpcr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        fault = checkFpEnableFault(xc);;
        uint64_t Fa = 0;
uint64_t FPCR = 0;
;
        FPCR = xc->readMiscRegOperand(this, 0);
;
         Fa = FPCR; ;

        if (fault == NoFault) {
            
        {
            uint64_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// WarnUnimpl::fetch([],{})

// WarnUnimpl::fetch_m([],{})

// WarnUnimpl::ecb([],{})

// MiscPrefetch::wh64([' EA = Rb & ~ULL(63); ', ' ; '],{'mem_flags': 'PREFETCH'})

    Fault Wh64::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA M5_VAR_USED;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb & ~ULL(63); ;

        warn_once("Prefetch instructions in Alpha do not do anything\n");
        if (fault == NoFault) {
             ; ;
        }

        return NoFault;
    }

    Fault Wh64::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = Rb & ~ULL(63); ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Wh64::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("initiateAcc undefined: Misc instruction does not support split "
             "access method!");
        return NoFault;
    }

    Fault Wh64::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        warn("completeAcc undefined: Misc instruction does not support split "
             "access method!");

        return NoFault;
    }

// BasicOperate::rpcc(['\n                /* Rb is a fake dependency so here is a fun way to get\n                 * the parser to understand that.\n                 */\n                uint64_t unused_var M5_VAR_USED = Rb;\n                Ra = FullSystem ? xc->readMiscReg(IPR_CC) : curTick();\n            ', 'IsUnverifiable'],{})

    Fault Rpcc::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
        
                /* Rb is a fake dependency so here is a fun way to get
                 * the parser to understand that.
                 */
                uint64_t unused_var M5_VAR_USED = Rb;
                Ra = FullSystem ? xc->readMiscReg(IPR_CC) : curTick();
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::trapb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    Fault Trapb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
         ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::excb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    Fault Excb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
         ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::mb([' ', 'IsMemBarrier', 'MemReadOp'],{})

    Fault Mb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
         ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::wmb([' ', 'IsWriteBarrier', 'MemWriteOp'],{})

    Fault Wmb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
         ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// FailUnimpl::rc_se(([], {}))

// BasicOperate::rc((['\n                Ra = IntrFlag;\n                IntrFlag = 0;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    Fault Rc::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t IntrFlag = 0;
;
        IntrFlag = xc->readMiscRegOperand(this, 0);
;
        
                Ra = IntrFlag;
                IntrFlag = 0;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 1, IntrFlag);
if (traceData) { traceData->setData(IntrFlag); };
        }

        return fault;
    }

// FailUnimpl::rs_se(([], {}))

// BasicOperate::rs((['\n                Ra = IntrFlag;\n                IntrFlag = 1;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    Fault Rs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t IntrFlag = 0;
;
        IntrFlag = xc->readMiscRegOperand(this, 0);
;
        
                Ra = IntrFlag;
                IntrFlag = 1;
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 1, IntrFlag);
if (traceData) { traceData->setData(IntrFlag); };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// EmulatedCallPal::halt(['\n                    exitSimLoop("halt instruction encountered");\n                ', 'IsNonSpeculative'],{})

    Fault Halt::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    exitSimLoop("halt instruction encountered");
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// EmulatedCallPal::callsys(['\n                    xc->syscall(R0);\n                ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall'],{})

    Fault Callsys::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
;
        R0 = xc->readIntRegOperand(this, 0);
;
        
                    xc->syscall(R0);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// EmulatedCallPal::rduniq([' R0 = Runiq; ', 'IsIprAccess'],{})

    Fault Rduniq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
uint64_t Runiq = 0;
;
        Runiq = xc->readMiscRegOperand(this, 0);
;
         R0 = Runiq; ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// EmulatedCallPal::wruniq([' Runiq = R16; ', 'IsIprAccess'],{})

    Fault Wruniq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Runiq = 0;
uint64_t R16 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
;
         Runiq = R16; ;

        if (fault == NoFault) {
            xc->setMiscRegOperand(this, 0, Runiq);
if (traceData) { traceData->setData(Runiq); };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// CallPal::call_pal((['\n            if (!palValid ||\n                (palPriv\n                 && xc->readMiscReg(IPR_ICM) != mode_kernel)) {\n                // invalid pal function code, or attempt to do privileged\n                // PAL call in non-kernel mode\n                fault = new UnimplementedOpcodeFault;\n            } else {\n                // check to see if simulator wants to do something special\n                // on this PAL call (including maybe suppress it)\n                bool dopal = xc->simPalCheck(palFunc);\n\n                if (dopal) {\n                    xc->setMiscReg(IPR_EXC_ADDR, NPC);\n                    NPC = xc->readMiscReg(IPR_PAL_BASE) + palOffset;\n                }\n            }\n        ', 'IsNonSpeculative'], {}))

    Fault Call_pal::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t NPC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
NPC = __parserAutoPCState.npc();
;
        
            if (!palValid ||
                (palPriv
                 && xc->readMiscReg(IPR_ICM) != mode_kernel)) {
                // invalid pal function code, or attempt to do privileged
                // PAL call in non-kernel mode
                fault = new UnimplementedOpcodeFault;
            } else {
                // check to see if simulator wants to do something special
                // on this PAL call (including maybe suppress it)
                bool dopal = xc->simPalCheck(palFunc);

                if (dopal) {
                    xc->setMiscReg(IPR_EXC_ADDR, NPC);
                    NPC = xc->readMiscReg(IPR_PAL_BASE) + palOffset;
                }
            }
        ;

        if (fault == NoFault) {
            __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        }

        return fault;
    }

// OpcdecFault::hw_st_quad(([], {}))

// HwLoad::hw_ld([' EA = (Rb + disp) & ~3; ', ' Ra = Mem_ul; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    Fault Hw_ldL::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Hw_ldL::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Hw_ldL::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Hw_ldL::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint32_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// HwLoad::hw_ld([' EA = (Rb + disp) & ~7; ', ' Ra = Mem_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    Fault Hw_ldQ::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

    Fault Hw_ldQ::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Hw_ldQ::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Rb = xc->readIntRegOperand(this, 0);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

    Fault Hw_ldQ::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Mem = 0;
;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
             Ra = Mem; ;
        }

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_st_cond(([], {}))

// HwStore::hw_st([' EA = (Rb + disp) & ~3; ', ' Mem_ul = Ra<31:0>; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    Fault Hw_stL::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Hw_stL::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Hw_stL::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint32_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~3; ;

        if (fault == NoFault) {
             Mem = bits(Ra, 31, 0); ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Hw_stL::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// HwStore::hw_st([' EA = (Rb + disp) & ~7; ', ' Mem_uq = Ra_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    Fault Hw_stQ::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            ;
        }

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

    Fault Hw_stQ::eaComp(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Rb = 0;
;
        Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
            ;
            xc->setEA(EA);
        }

        return fault;
    }

    Fault Hw_stQ::initiateAcc(CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
uint64_t Rb = 0;
uint64_t Mem = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
Rb = xc->readIntRegOperand(this, 1);
;
         EA = (Rb + disp) & ~7; ;

        if (fault == NoFault) {
             Mem = Ra; ;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA,
                    memAccessFlags, NULL);
        }

        return fault;
    }

    Fault Hw_stQ::completeAcc(PacketPtr pkt,
                                      CPU_EXEC_CONTEXT *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// FailUnimpl::hw_st_cond(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mfpr(([], {}))

// HwMoveIPR::hw_mfpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsReadable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    Ra = xc->readMiscReg(miscRegIndex);\n            ', 'IsIprAccess'],{})

    Fault Hw_mfpr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
;
        ;
        
                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?
                        IprToMiscRegIndex[ipr_index] : -1;
                if(miscRegIndex < 0 || !IprIsReadable(miscRegIndex) ||
                    miscRegIndex >= NumInternalProcRegs)
                        fault = new UnimplementedOpcodeFault;
                else
                    Ra = xc->readMiscReg(miscRegIndex);
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mtpr(([], {}))

// HwMoveIPR::hw_mtpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsWritable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    xc->setMiscReg(miscRegIndex, Ra);\n                if (traceData) { traceData->setData(Ra); }\n            ', 'IsIprAccess'],{})

    Fault Hw_mtpr::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
;
        Ra = xc->readIntRegOperand(this, 0);
;
        
                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?
                        IprToMiscRegIndex[ipr_index] : -1;
                if(miscRegIndex < 0 || !IprIsWritable(miscRegIndex) ||
                    miscRegIndex >= NumInternalProcRegs)
                        fault = new UnimplementedOpcodeFault;
                else
                    xc->setMiscReg(miscRegIndex, Ra);
                if (traceData) { traceData->setData(Ra); }
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// OpcdecFault::hw_rei(([], {}))

// BasicOperate::hw_rei([' xc->hwrei(); ', 'IsSerializing', 'IsSerializeBefore'],{})

    Fault Hw_rei::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
         xc->hwrei(); ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// BasicOperate::arm(['\n                PseudoInst::arm(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    Fault Arm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                PseudoInst::arm(xc->tcBase());
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::quiesce(["\n                // Don't sleep if (unmasked) interrupts are pending\n                Interrupts* interrupts =\n                    xc->tcBase()->getCpuPtr()->getInterruptController();\n                if (interrupts->checkInterrupts(xc->tcBase())) {\n                    PseudoInst::quiesceSkip(xc->tcBase());\n                } else {\n                    PseudoInst::quiesce(xc->tcBase());\n                }\n            ", 'IsNonSpeculative', 'IsQuiesce'],{})

    Fault Quiesce::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                // Don't sleep if (unmasked) interrupts are pending
                Interrupts* interrupts =
                    xc->tcBase()->getCpuPtr()->getInterruptController();
                if (interrupts->checkInterrupts(xc->tcBase())) {
                    PseudoInst::quiesceSkip(xc->tcBase());
                } else {
                    PseudoInst::quiesce(xc->tcBase());
                }
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::quiesceNs(['\n                PseudoInst::quiesceNs(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce'],{})

    Fault QuiesceNs::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
;
        
                PseudoInst::quiesceNs(xc->tcBase(), R16);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::quiesceCycles(['\n                PseudoInst::quiesceCycles(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce', 'IsUnverifiable'],{})

    Fault QuiesceCycles::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
;
        
                PseudoInst::quiesceCycles(xc->tcBase(), R16);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::quiesceTime(['\n                R0 = PseudoInst::quiesceTime(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    Fault QuiesceTime::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
;
        ;
        
                R0 = PseudoInst::quiesceTime(xc->tcBase());
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::rpns(['\n                R0 = PseudoInst::rpns(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    Fault Rpns::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
;
        ;
        
                R0 = PseudoInst::rpns(xc->tcBase());
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::wakeCPU(['\n                PseudoInst::wakeCPU(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    Fault WakeCPU::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
;
        
                PseudoInst::wakeCPU(xc->tcBase(), R16);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::deprecated_ivlb(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    Fault Deprecated_ivlb::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn_once("Obsolete M5 ivlb instruction encountered.\n");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::deprecated_ivle(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    Fault Deprecated_ivle::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn_once("Obsolete M5 ivlb instruction encountered.\n");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::deprecated_exit(['\n                warn_once("deprecated M5 exit instruction encountered.\\n");\n                PseudoInst::m5exit(xc->tcBase(), 0);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    Fault Deprecated_exit::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn_once("deprecated M5 exit instruction encountered.\n");
                PseudoInst::m5exit(xc->tcBase(), 0);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5exit(['\n                PseudoInst::m5exit(xc->tcBase(), R16);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    Fault M5exit::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
;
        
                PseudoInst::m5exit(xc->tcBase(), R16);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::loadsymbol(['\n                PseudoInst::loadsymbol(xc->tcBase());\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    Fault Loadsymbol::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                PseudoInst::loadsymbol(xc->tcBase());
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::initparam(['\n                Ra = PseudoInst::initParam(xc->tcBase());\n            '],{})

    Fault Initparam::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t Ra = 0;
;
        ;
        
                Ra = PseudoInst::initParam(xc->tcBase());
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = Ra;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::resetstats(['\n                PseudoInst::resetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    Fault Resetstats::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
uint64_t R17 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
;
        
                PseudoInst::resetstats(xc->tcBase(), R16, R17);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::dumpstats(['\n                PseudoInst::dumpstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    Fault Dumpstats::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
uint64_t R17 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
;
        
                PseudoInst::dumpstats(xc->tcBase(), R16, R17);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::dumpresetstats(['\n                PseudoInst::dumpresetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    Fault Dumpresetstats::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
uint64_t R17 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
;
        
                PseudoInst::dumpresetstats(xc->tcBase(), R16, R17);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5checkpoint(['\n                PseudoInst::m5checkpoint(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    Fault M5checkpoint::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
uint64_t R17 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
;
        
                PseudoInst::m5checkpoint(xc->tcBase(), R16, R17);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5readfile(['\n                R0 = PseudoInst::readfile(xc->tcBase(), R16, R17, R18);\n            ', 'IsNonSpeculative'],{})

    Fault M5readfile::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
uint64_t R16 = 0;
uint64_t R17 = 0;
uint64_t R18 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
R18 = xc->readIntRegOperand(this, 2);
;
        
                R0 = PseudoInst::readfile(xc->tcBase(), R16, R17, R18);
            ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::m5break(['\n                PseudoInst::debugbreak(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    Fault M5break::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                PseudoInst::debugbreak(xc->tcBase());
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5switchcpu(['\n                PseudoInst::switchcpu(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    Fault M5switchcpu::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                PseudoInst::switchcpu(xc->tcBase());
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5addsymbol(['\n                PseudoInst::addsymbol(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    Fault M5addsymbol::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R16 = 0;
uint64_t R17 = 0;
;
        R16 = xc->readIntRegOperand(this, 0);
R17 = xc->readIntRegOperand(this, 1);
;
        
                PseudoInst::addsymbol(xc->tcBase(), R16, R17);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5panic(['\n                panic("M5 panic instruction called at pc = %#x.", PC);\n            ', 'IsNonSpeculative'],{})

    Fault M5panic::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t PC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.pc();
;
        
                panic("M5 panic instruction called at pc = %#x.", PC);
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }
#define  CPANN(lbl) CPA::cpa()->lbl(xc->tcBase())

// BasicOperate::m5a_old(['\n                    panic("Deprecated M5 annotate instruction executed "\n                          "at pc = %#x\\n", PC);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_old::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t PC;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.pc();
;
        
                    panic("Deprecated M5 annotate instruction executed "
                          "at pc = %#x\n", PC);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_bsm(['\n                    CPANN(swSmBegin);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_bsm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swSmBegin);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_esm(['\n                    CPANN(swSmEnd);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_esm::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swSmEnd);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_begin(['\n                    CPANN(swExplictBegin);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_begin::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swExplictBegin);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_end(['\n                    CPANN(swEnd);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_end::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swEnd);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_q(['\n                    CPANN(swQ);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_q::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swQ);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_dq(['\n                    CPANN(swDq);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_dq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swDq);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_wf(['\n                    CPANN(swWf);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_wf::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swWf);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_we(['\n                    CPANN(swWe);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_we::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swWe);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_sq(['\n                    CPANN(swSq);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_sq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swSq);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_aq(['\n                    CPANN(swAq);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_aq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swAq);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_pq(['\n                    CPANN(swPq);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_pq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swPq);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_l(['\n                    CPANN(swLink);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_l::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swLink);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_identify(['\n                    CPANN(swIdentify);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_identify::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swIdentify);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_getid(['\n                    R0 = CPANN(swGetId);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_getid::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        uint64_t R0 = 0;
;
        ;
        
                    R0 = CPANN(swGetId);
                ;

        if (fault == NoFault) {
            
        
        {
            uint64_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
        }

        return fault;
    }

// BasicOperate::m5a_scl(['\n                    CPANN(swSyscallLink);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_scl::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swSyscallLink);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5a_rq(['\n                    CPANN(swRq);\n                ', 'IsNonSpeculative'],{})

    Fault M5a_rq::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                    CPANN(swRq);
                ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// Unknown::unknown(([], {}))
#undef CPANN

// BasicOperate::m5reserved2(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    Fault M5reserved2::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn("M5 reserved opcode ignored");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5reserved3(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    Fault M5reserved3::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn("M5 reserved opcode ignored");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5reserved4(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    Fault M5reserved4::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn("M5 reserved opcode ignored");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// BasicOperate::m5reserved5(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    Fault M5reserved5::execute(CPU_EXEC_CONTEXT *xc,
                                  Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        ;
        ;
        ;
        
                warn("M5 reserved opcode ignored");
            ;

        if (fault == NoFault) {
            ;
        }

        return fault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

#endif
